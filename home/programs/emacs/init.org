#+title: My Emacs Config
#+author: marimo
#+STARTUP: fold

* 設定方針
** DONE Home-managerで管理する
- State "DONE"       from "TODO"       [2024-07-18 Thu 10:24]
[[https://apribase.net/2024/06/13/emacs-home-manager-init-org/]]

** CANCELED Leafに移行？
CLOSED: [2024-07-03 Wed 06:02]
[[https://github.com/conao3/leaf.el]]

** DONE zk-phi/setupの活用
- State "DONE"       from "TODO"       [2024-07-18 Thu 10:24]
コンパイル時計算を使う!
[[https://github.com/zk-phi/setup]]

** DONE zk-phi/setupの改善
CLOSED: [2024-08-20 Tue 17:29]
:LOGBOOK:
- State "DONE"       from "TODO"       [2024-08-20 Tue 17:29]
:END:
init.el内のrequireを全部パスを解決したloadに変換してくれているが、
これだとelnを読んでくれていない
setup--locate-libraryがやってるので、こいつを書きかえればいい
こいつはただのlocate-libraryのラッパー
locate-libraryはelnの場所を返してくれない
comp-el-to-eln-filenameが良さそうか？
自前でnative-comp-eln-load-pathとcomp-native-version-dirを使って読むしかないかも
comp-lookup-elnとlocate-libraryを組み合わせればよさそう
comp-lookup-elnは.elじゃないとだめっぽいのでlocate-libraryでとってきたやつが.elcならcを消す

** DONE コンパイルを使った高速化
- State "DONE"       from "TODO"       [2024-07-18 Thu 10:24]
[[https://github.com/nilcons/emacs-use-package-fast]]
load-pathをコンパイル時に解決することで、
package.elをロードしないようにして高速化する。

したがって、実際に設定するには、
1. パッケージをインストールするために直接生のinit.elを実行する
2. インストールできたらコンパイル
となる

コンパイルしたら実行時にはleafもpackageもロードされない

** DONE Dashboardをやめる
- State "DONE"       from "TODO"       [2024-07-18 Thu 10:24]
Dashboardを使うとOrgを読むので起動が遅い
なんならstartupも消しちゃうか
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src

** Window Almanac
https://qiita.com/ayatakesi/items/8e5824c5622c59c6946c
https://karthinks.com/software/emacs-window-management-almanac

** CANCELED Load-pathのコンパイル時解決
https://misohena.jp/blog/2022-12-26-fast-locate-library-on-nt-emacs.html
この辺を参考にrequireを高速化する？
Nixでelispをインストールするとsite-lispに全部入って、subdirs.elでload-pathに追加される
load-pathが結構大きいのでワンチャン効果があるかもしれない
** LaTeXの入力高速化を考える
https://karthinks.com/software/latex-input-for-impatient-scholars/
https://www.reddit.com/r/emacs/comments/g8ecpj/comment/foo64ge/
** Avyをもっと
単に移動するだけでなく
あとはmigemoも付けないとね
https://emacs-jp.github.io/tips/avy-can-do-anything

** Embarkを使えるようにする
Embarkをとりあえず叩くぐらいまで手に馴染ませる
https://emacs-jp.github.io/tips/fifteen-ways-to-use-embark

* early-init.el
:PROPERTIES:
:header-args: :tangle early-init.el :noweb yes
:END:
** Header
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
#+end_src

** UI
#+begin_src emacs-lisp
(with-eval-after-load 'scroll-bar
  (scroll-bar-mode -1))
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(cursor-type . bar) default-frame-alist)
(setq frame-inhibit-implied-resize t)
#+end_src

** backupとかlockとか
#+begin_src emacs-lisp
(setq make-backup-files nil)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/backup/" t)))
(setq auto-save-timeout 10)
(setq auto-save-interval 100)
(setq auto-save-list-file-prefix nil)
(setq create-lockfiles nil)
#+end_src

** startupの諸々をとめる
#+begin_src emacs-lisp
(setq inhibit-startup-message t)
(setq inhibit-startup-echo-area-message t)
(setq inhibit-startup-buffer-menu t)
(setq inhibit-startup-screen t)
#+end_src

** read-process
#+begin_src emacs-lisp
(setq read-process-output-max (* 8 1024 1024))
#+end_src

** GC
#+begin_src emacs-lisp
(setq gc-cons-threshold (* 128 1024 1024))
(setq garbage-collection-messages nil)
#+end_src

** X Resourcesをよまない
#+begin_src emacs-lisp
(advice-add 'x-apply-session-resources :override 'ignore)
#+end_src

** customizeでinit.elにかきこまない
#+begin_src emacs-lisp
(setq custom-file "~/.emacs.d/custom.el")
#+end_src

** package.elをとめる
#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
#+end_src

** LSP-modeでplistを使うようにする
#+begin_src emacs-lisp
(setenv "LSP_USE_PLISTS" "true")
#+end_src

** footer
#+begin_src emacs-lisp
(provide 'early-init)
#+end_src

* init.el
:PROPERTIES:
:header-args: :tangle init.el :noweb yes
:END:
** Header
#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

** setup.el
コンパイル環境のチェックが入るとNixでコンパイルした時怒られが発生するので止める
ちなみにzk-phi/setupのこと
#+begin_src emacs-lisp
(eval-when-compile
  (require 'cl-lib)
  (require 'setup)
  (setq setup-silent t
        ;; setup-use-profiler t
        ;; setup-use-load-history-tracker t
        setup-delay-interval 0.5
        setup-disable-magic-file-name t)
  (defmacro setup--checkenv ())
  (defun my/setup--locate-library (file)
    (unless (member file setup--simulated-absent-libraries)
      (or (let ((el-file (locate-library (concat file ".el"))))
            (when el-file
              (comp-lookup-eln el-file)))
          (locate-library file))))
  (advice-add #'setup--locate-library :override #'my/setup--locate-library))
(setup-initialize)
#+end_src

** package.el
もともとはコンパイル時にインストールする目論みだったけど、全部Nixでインストールすることにした
#+begin_src emacs-lisp :tangle no
(eval-and-compile
  (setq package-archives '(("org" . "https://orgmode.org/elpa/")
                          ("melpa" . "https://melpa.org/packages/")
                          ("gnu" . "https://elpa.gnu.org/packages/"))
        package-install-upgrade-built-in t
        package-native-compile t)
  (mapc #'(lambda (add) (add-to-list 'load-path add))
        (eval-when-compile
          (require 'package)
          (package-initialize)
          (let ((package-user-dir-real (file-truename package-user-dir)))
            (nreverse (apply #'nconc
                             (mapcar #'(lambda (path)
                                         (if (string-prefix-p package-user-dir-real path)
                                             (list path)
                                           nil))
                                     load-path)))))))
#+end_src

*** ensure
- インタプリタで実行されるとき
- コンパイル時
にだけインストールする。
(つもりだったけど、なんかうまくいかないのでこうしておく)
#+begin_src emacs-lisp
;(defmacro ensure (pkg)
;  (unless (package-installed-p pkg)
;    `(package-install ,pkg)))
;(defmacro ensure-vc (arg)
;  (unless (package-installed-p (car arg))
;    `(package-vc-install ,arg)))
(defmacro ensure (pkg) `())
(defmacro ensure-vc (pkg) `())
#+end_src

** 標準の設定
*** パフォーマンスに関する設定
#+begin_src emacs-lisp
(setq process-adaptive-read-buffering t)
(setq blink-matching-paren nil)
(setq vc-handled-backends '(Git))
(setq auto-mode-case-fold nil)
(setq-default bidi-display-reordering 'left-to-right)
(setq bidi-inhibit-bpa t)
(setq-default cursor-in-non-selected-windows nil)
(setq highlight-nonselected-windows nil)
(setq fast-but-imprecise-scrolling t)
(setq idle-update-delay 1.0)
(setq redisplay-skip-fontification-on-input t)
(setq inhibit-compacting-font-caches t)
#+end_src

*** Mac固有の設定
#+begin_src emacs-lisp
(!when (equal window-system 'mac)
  (setq mac-option-modifier 'meta
        mac-command-modifier 'super)
  (mac-auto-ascii-mode 1))
(!when (and (memq window-system '(ns nil))
            (fboundp 'mac-get-current-input-source))
  (mac-input-method-mode 1)
  (setopt ns-control-modifier 'control
        ns-option-modifier 'super
        ns-command-modifier 'meta
        ns-right-control-modifier 'control
        ns-right-option-modifier 'hyper
        ns-right-command-modifier 'meta))
#+end_src

*** その他
#+begin_src emacs-lisp
(setq completion-cycle-threshold 3
      use-short-answers t)
#+end_src

** envrc
#+begin_src emacs-lisp
(!-
 (setup "envrc"
   (envrc-global-mode)))
#+end_src

** コーディング
*** Corfu
#+begin_src emacs-lisp
(!-
 (setup "corfu"
   (setup "orderless")
   ;;(setup "hotfuzz")
   (setopt corfu-auto t
         corfu-auto-prefix 2
         corfu-auto-delay 0.1
         corfu-popupinfo-delay nil
         corfu-cycle t
         corfu-preselect 'prompt
         corfu-quit-no-match t
         corfu-quit-at-boundary t
         corfu-scroll-margin 2
         tab-always-indent 'complete
         tab-first-completion nil
         text-mode-ispell-word-completion nil)

   (setup "corfu-prescient"
     (setq corfu-prescient-enable-filtering nil)
     (corfu-prescient-mode t))

   (unless (display-graphic-p)
     (defvar corfu-terminal-mode nil)
     (setup "corfu-terminal"
       (corfu-terminal-mode 1)))

   (setup "corfu-popupinfo"
     (setup-hook 'corfu-mode-hook #'corfu-popupinfo-mode))

   (setup "nerd-icons-corfu"
     (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

   (setup "cape"
     (setup "cape-keyword")
     (setq cape-dabbrev-check-other-buffers #'cape--buffers-major-mode)
     (setq-default completion-at-point-functions
                   '(cape-dabbrev
                     cape-file
                     cape-keyword)))

   (global-corfu-mode 1)

   (keymap-unset corfu-map "<remap> <next-line>")
   (keymap-unset corfu-map "<remap> <previous-line>")
   (setup-keybinds corfu-map
     "<tab>" 'corfu-next
     "<backtab>" 'corfu-previous)))
#+end_src

*** Undo/Redo
#+begin_src emacs-lisp
(setup-lazy '(undo-fu-only-undo
              undo-fu-only-redo)
  "undo-fu"
  :prepare (setup-keybinds nil
             "M-z" 'undo-fu-only-undo
             "M-S-z" 'undo-fu-only-redo)) ;; same as Mac undo/redo keybinds
(setup-lazy '(vundo) "vundo"
  :prepare (setup-keybinds nil
             "C-c z" 'vundo)
  (setopt vundo-glyph-alist vundo-unicode-symbols
          vundo-window-max-height 10))
#+end_src

*** Region
set-markはC-SPCでやるので（システム側のIME変更のキーバインドは潰してある）、C-@はあいている
#+begin_src emacs-lisp
(setup-lazy '(expreg-expand) "expreg"
  :prepare (setup-keybinds nil
             "C-@" 'expreg-expand))
#+end_src

*** Puni
#+begin_src emacs-lisp
(setup-lazy
  '(puni-mark-list-around-point
    puni-mark-sexp-around-point
    puni-expand-region
    puni-wrap-round
    puni-wrap-square
    puni-wrap-curly
    puni-wrap-angle
    puni-splice
    puni-slurp-forward
    puni-barf-forward)
  "puni")
#+end_src

*** LSP-mode
#+begin_src emacs-lisp
(setup-lazy '(lsp lsp-deferred lsp-org) "lsp-mode"
  (setup "lsp-mode-autoloads")
  (setup "lsp-ui")
  (setup-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)
  (setup-hook 'lsp-mode-hook #'flymake-mode)
  (setopt lsp-headerline-breadcrumb-enable nil
          lsp-modeline-code-actions-enable nil
          lsp-modeline-diagnostics-enable nil
          lsp-diagnostics-provider :flymake))
(setup-after "lsp-completion"
  (setopt lsp-completion-provider :none)
  (defun my/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))) ;; Configure orderless
  (setup-hook 'lsp-completion-mode-hook #'my/lsp-mode-setup-completion))
#+end_src

lsp-boosterもね
#+begin_src emacs-lisp
(defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
            (setcar orig-result command-from-exec-path))
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)
#+end_src

あとはUIまわりも
#+begin_src emacs-lisp
(setup-after "lsp-ui"
  (setopt lsp-ui-doc-enable t
          lsp-ui-flycheck-enable nil
          lsp-ui-peek-enable t))
#+end_src

*** flymake
#+begin_src emacs-lisp
(setup-lazy '(flymake-mode) "flymake"
  (setup-keybinds flymake-mode-map
    "C-c n" 'flymake-goto-next-error
    "C-c p" 'flymake-goto-prev-error))
#+end_src

*** Git
**** magit
なんかキラーアプリらしいけどうまく使えてない
#+begin_src emacs-lisp
(setup-lazy '(magit magit-status) "magit")
#+end_src

**** diff-hl
git diffの情報をいい感じにだしてくれるやつ
#+begin_src emacs-lisp
(!-
 (setup "diff-hl"
   (global-diff-hl-mode 1)
   (setup-hook 'dired-mode-hook #'diff-hl-dired-mode)
   (setup-hook 'magit-pre-refresh-hook #'diff-hl-magit-pre-refresh)
   (setup-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)
   (unless (window-system)
     (diff-hl-margin-mode))))
#+end_src
*** Treesitter
GrammarはNixでインストールされるのでtreesit-autoは御役御免
#+begin_src emacs-lisp
(setup-after "treesit"
  (setopt treesit-font-lock-level 4))
(!foreach '((bash-mode . bash-ts-mode)
            (c-mode . c-ts-mode)
            (c++-mode . c++-ts-mode)
            (csharp-mode . csharp-ts-mode)
            (cmake-mode . cmake-ts-mode)
            (css-mode . css-ts-mode)
            (dockerfile-mode . dockerfile-ts-mode)
            (python-mode . python-ts-mode))
  (add-to-list 'major-mode-remap-alist ,it))
(!foreach '(("[Dd]ockerfile\\'" . dockerfile-ts-mode)
            ("\\.dockerfile\\'" . dockerfile-ts-mode)
            ("\\.yaml\\'" . yaml-ts-mode))
  (add-to-list 'auto-mode-alist ,it))

#+end_src

**** treesit-fold
#+begin_src emacs-lisp
(setup "treesit-fold"
  (global-treesit-fold-mode))
#+end_src

*** 言語ごとのmajor mode
**** Gnuplot
#+begin_src emacs-lisp
(setup-lazy '(gnuplot-mode) "gnuplot"
  :prepare
  (progn
    (add-to-list 'auto-mode-alist '("\\.plt\\'" . gnuplot-mode))
    (add-to-list 'auto-mode-alist '("\\.gp\\'" . gnuplot-mode)))
  (setup "gnuplot-context"))
#+end_src

**** Julia
#+begin_src emacs-lisp
(setup-lazy '(julia-mode) "julia-mode"
  :prepare (add-to-list 'auto-mode-alist '("\\.jl\\'" . julia-mode)))
#+end_src

**** LaTeX
ほとんどcdlatexがめあて
+Tempelで展開するので、cdlatexのTabでのコマンドの展開は消す+
#+begin_src emacs-lisp
(setup-lazy '(texmathp) "texmathp")
(setup-after "cdlatex"
  (setq cdlatex-command-alist-comb nil))
#+end_src

**** Lean4
#+begin_src emacs-lisp
(setup-lazy '(lean4-select-mode) "lean4-mode"
  :prepare (add-to-list 'auto-mode-alist '("\\.lean\\'" . lean4-select-mode)))
#+end_src

**** Nix
#+begin_src emacs-lisp
(setup-lazy '(nix-ts-mode) "nix-ts-mode"
  :prepare (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-ts-mode)))
#+end_src

**** Nushell
#+begin_src emacs-lisp
(setup-lazy '(nushell-ts-mode) "nushell-ts-mode"
  :prepare
  (progn
    (add-to-list 'auto-mode-alist '("\\.nu\\'" . nushell-ts-mode))
    (add-to-list 'interpreter-mode-alist '("nu" . nushell-ts-mode))))
#+end_src

**** Ocaml
#+begin_src emacs-lisp
(setup-lazy '(tuareg-mode
              tuareg-opam-mode) "tuareg"
  :prepare (progn
             (add-to-list 'auto-mode-alist '("[./]opam_?\\'" . tuareg-opam-mode))
             (add-to-list 'auto-mode-alist '("\\.ml[ip]?\\'" . tuareg-mode))))
#+end_src

**** SATySFi
satysfi-ts-modeをつかいます
#+begin_src emacs-lisp
(setup-lazy '(satysfi-ts-mode) "satysfi-ts-mode"
  :prepare (progn
             (add-to-list 'auto-mode-alist '("\\.saty\\'" . satysfi-ts-mode))
             (add-to-list 'auto-mode-alist '("\\.satyh\\'" . satysfi-ts-mode))
             (add-to-list 'auto-mode-alist '("\\.satyg\\'" . satysfi-ts-mode))))
#+end_src

**** Typst
#+begin_src emacs-lisp
(setup-lazy '(typst-ts-mode) "typst-ts-mode"
  :prepare (add-to-list 'auto-mode-alist '("\\.typ\\'" . typst-ts-mode))
  (setopt typst-ts-mode-indent-offset 2))
#+end_src

**** Rust
#+begin_src emacs-lisp
(setup-lazy '(rust-mode) "rust-mode"
  :prepare (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
  (setq rust-mode-treesitter-derive t))
#+end_src

** server
#+begin_src emacs-lisp
(!-
 (setup "server"
  (unless (server-running-p)
    (server-start))))
#+end_src

** whitespace
#+begin_src emacs-lisp
(setup-lazy '(whitespace-mode) "whitespace"
  :prepare (setup-hook 'find-file-hook 'whitespace-mode)
  (setq whitespace-style '(face
                           trailing
                           tabs
                           spaces
                           empty
                           space-mark
                           tab-mark)
        whitespace-display-mappings '((space-mark ?\u3000 [?\u25a1])
                                      (tab-mark ?\t [?\u00BB ?\t] [?\\ ?\t]))
        whitespace-space-regexp "\\(\u3000+\\)"
        whitespace-trailing-regexp "\\([ \u00A0]+\\)$"
        whitespace-action '(auto-cleanup)))
#+end_src

** autorevert
#+begin_src emacs-lisp
(!-
 (setup "autorevert"
   (setq auto-revert-avoid-polling t)
   (global-auto-revert-mode 1)))
#+end_src

** recentf
#+begin_src emacs-lisp
(!-
 (setup "recentf"
   (recentf-mode)))
#+end_src

** delsel
#+begin_src emacs-lisp
(!-
 (setup "delsel"
   (delete-selection-mode 1)))
#+end_src

** subword
#+begin_src emacs-lisp
(setup-lazy '(subword-mode) "subword"
  :prepare (setup-hook 'prog-mode-hook #'subword-mode))
#+end_src

** tramp
NixOSのためにpathを追加する
#+begin_src emacs-lisp
(setup-after "tramp"
  (setq tramp-default-method "scpx")
  (add-to-list 'tramp-remote-path "/run/current-system/sw/bin")
  (add-to-list 'tramp-remote-path "/run/wrappers/bin"))
#+end_src

** comp
#+begin_src emacs-lisp
(setup-after "comp"
  (setq native-comp-async-report-warnings-errors 'silent))
#+end_src

** Fancy UI
*** Font
early-init.elでdefault-frame-alistに指定してあるけど、unicodeはまだ設定されてなくて日本語が表示できないので遅延して設定する
#+begin_src emacs-lisp :tangle no
(!-
  (set-fontset-font
    "fontset-startup"
    'unicode
    "UDEV Gothic LG-12"
    nil
    'append))
#+end_src

variable-pitchに真面目に対応する
variable-pitch-modeにしたとき、bold体の太さのバランスが良くないので調整したい
fontsetをweightまで指定したfontspecで作れば別のweightで表示することはできる
しかし、雑にbold faceを書き換えるとvariable-pitchにしたくない部分も影響されてしまう
ここが *未解決*
おそらくはef-themesやmixed-pitchがやっているような解決(variable-pitchにしたくないfaceを列挙する)をしないといけない

#+begin_src emacs-lisp
(defface variable-pitch-bold
  '((t :inherit default))
  "")

(defun my/set-font()
  (let* ((size 11)
         (height (* size 10))
         (propo "Noto Serif CJK JP")
         (mono "UDEV Gothic LG")
         (propo-bold (font-spec :family propo :weight 'medium))
         (mono-bold (font-spec :family mono :weight 'bold)))
    ;; variable-pitch
    (create-fontset-from-ascii-font propo nil "proportional")
    (set-fontset-font "fontset-proportional" 'latin propo)
    (set-fontset-font "fontset-proportional" 'unicode propo nil 'append)
    (set-face-attribute 'variable-pitch nil
                        :font "fontset-proportional"
                        :fontset "fontset-proportional"
                        :height height)
    ;; variable-pitch-bold
    (create-fontset-from-ascii-font propo nil "proportionalbold")
    (set-fontset-font "fontset-proportionalbold" 'latin propo-bold)
    (set-fontset-font "fontset-proportionalbold" 'unicode mono-bold nil 'append)
    (set-face-attribute 'variable-pitch-bold nil
                        :font "fontset-proportionalbold"
                        :fontset "fontset-proportionalbold"
                        :height height)
    (set-face-attribute 'bold nil :weight 'semibold)
    ;; fixed-pitch
    (create-fontset-from-ascii-font mono nil "fixed")
    (set-fontset-font "fontset-fixed" 'latin mono)
    (set-fontset-font "fontset-fixed" 'unicode mono)
    (set-face-attribute 'fixed-pitch nil
                        :font "fontset-fixed"
                        :fontset "fontset-fixed"
                        :height height)
    ;; default fontset
    (set-fontset-font t 'unicode mono)
    (set-face-attribute 'default nil
                        :font "fontset-fixed"
                        :fontset "fontset-fixed"
                        :height height))
  (setq face-font-rescale-alist
        '((".*Inter.*" . 1.1))))

(defun my/proportional-font()
  "set current buffer to use proportional fonts.
   enable variable-pitch-mode
   and remap 'bold to 'variable-pitch-bold"
  ;;(face-remap-add-relative 'bold 'variable-pitch-bold)
  (variable-pitch-mode 1))

(when (display-graphic-p)
  (my/set-font))
#+end_src

**** Ligatureの対応
ligature.elでworkaroundする
#+begin_src emacs-lisp :noweb no
(!-
 (setup "ligature"
   (ligature-set-ligatures 'prog-mode '("--" "---" "==" "===" "!=" "!==" "=!="
                                        "=:=" "=/=" "<=" ">=" "&&" "&&&" "&=" "++" "+++" "***" ";;" "!!"
                                        "??" "???" "?:" "?." "?=" "<:" ":<" ":>" ">:" "<:<" "<>" "<<<" ">>>"
                                        "<<" ">>" "||" "-|" "_|_" "|-" "||-" "|=" "||=" "##" "###" "####"
                                        "#{" "#[" "]#" "#(" "#?" "#_" "#_(" "#:" "#!" "#=" "^=" "<$>" "<$"
                                        "$>" "<+>" "<+" "+>" "<*>" "<*" "*>" "</" "</>" "/>" "<!--" "<#--"
                                        "-->" "->" "->>" "<<-" "<-" "<=<" "=<<" "<<=" "<==" "<=>" "<==>"
                                        "==>" "=>" "=>>" ">=>" ">>=" ">>-" ">-" "-<" "-<<" ">->" "<-<" "<-|"
                                        "<=|" "|=>" "|->" "<->" "<~~" "<~" "<~>" "~~" "~~>" "~>" "~-" "-~"
                                        "~@" "[||]" "|]" "[|" "|}" "{|" "[<" ">]" "|>" "<|" "||>" "<||"
                                        "|||>" "<|||" "<|>" "..." ".." ".=" "..<" ".?" "::" ":::" ":=" "::="
                                        ":?" ":?>" "//" "///" "/*" "*/" "/=" "//=" "/==" "@_" "__" "???"
                                        "<:<" ";;;"))
   (global-ligature-mode t)))
#+end_src

*** Theme
ef-themesをつかう
#+begin_src emacs-lisp
(setup "ef-themes-autoloads"
  (setopt ef-themes-mixed-fonts t
          ef-themes-variable-pitch-ui nil)
  (load-theme 'ef-cyprus t))
#+end_src

*** Modeline, Headerline
nano-modelineでheaderのみ設定
modelineは消す
#+begin_src emacs-lisp
(setup "nano-modeline"
  (setq nano-modeline-padding '(0.2 . 0.25))
  (setq-default mode-line-format nil)
  (nano-modeline-text-mode t))
#+end_src

*** perfect-margin
#+begin_src emacs-lisp
(!-
 (setup "perfect-margin"
   (setopt perfect-margin-force-regexps '("*Minibuf" "*which-key"))
   (perfect-margin-mode 1)))
#+end_src

*** spacious-padding
#+begin_src emacs-lisp
(setup "spacious-padding"
  (setopt spacious-padding-widths
          '( :internal-border-width 15
             :header-line-width 4
             :mode-line-width 6
             :tab-width 4
             :right-divider-width 30
             :scroll-bar-width 8))
  (spacious-padding-mode 1))
#+end_src

*** nerd-icons
nerd-iconsを採用
#+begin_src emacs-lisp
(setup-after "nerd-icons"
  (ignore-errors (nerd-icons-set-font)))
#+end_src

#+begin_src emacs-lisp
(setup-after "marginalia"
  (setup "nerd-icons-completion"
    (nerd-icons-completion-mode)
    (setup-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup)))
#+end_src

*** scroll
pixel-scrollを使っていたけど、なんか重いのでやめる
やっぱり使いたくなった
#+begin_src emacs-lisp
(setopt mouse-wheel-scroll-amount '(1 ((shift) . 1))
        mouse-wheel-progressive-speed t
        mouse-wheel-follow-mouse t
        scroll-step 1)
(pixel-scroll-precision-mode 1)
#+end_src

*** rainbow-delimiters
#+begin_src emacs-lisp
(setup-lazy '(rainbow-delimiters-mode) "rainbow-delimiters"
  :prepare (setup-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

** インデント
*** タブの挙動
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
#+end_src

*** indent-bars
#+begin_src emacs-lisp
(setup-lazy '(indent-bars-mode) "indent-bars"
  :prepare
  (progn
    (setup-hook 'prog-mode-hook 'indent-bars-mode)
    (setup-hook 'yaml-mode-hook 'indent-bars-mode))
  (setup "indent-bars-ts")
  (setq indent-bars-treesit-support t
        indent-bars-treesit-ignore-blank-lines-types '("module")
        indent-bars-color '(highlight :face-bg t :blend 0.2)
        indent-bars-pattern "."
        indent-bars-width-frac 0.1
        indent-bars-pad-frac 0.1
        indent-bars-zigzag nil
        indent-bars-color-by-depth nil
        indent-bars-highlight-current-depth nil
        indent-bars-display-on-blank-lines nil))
#+end_src

*** aggressive-indent
#+begin_src emacs-lisp
(setup-lazy '(aggressive-indent-mode) "aggressive-indent"
  :prepare (setup-hook 'emacs-lisp-mode-hook 'aggressive-indent-mode))
#+end_src

*** electric-indent
#+begin_src emacs-lisp
(setup-hook 'prog-mode-hook 'electric-indent-mode)
#+end_src

** Minibuffer Completion
*** vertico, marginalia
vertico-mode
#+begin_src emacs-lisp
(setup-lazy '(vertico--advice) "vertico"
  :prepare (progn
             (advice-add 'completing-read-default :around 'vertico--advice)
             (advice-add 'completing-read-multiple :around 'vertico--advice))
  (setq vertico-cycle t)

  (setup "orderless")
  ;;(setup "hotfuzz")
  (setup "savehist")
  (setup "marginalia" (marginalia-mode))

  (defvar +vertico-current-arrow t)
  (cl-defmethod vertico--format-candidate :around
    (cand prefix suffix index start &context ((and +vertico-current-arrow
                                                   (not (bound-and-true-p vertico-flat-mode)))
                                              (eql t)))
    (setq cand (cl-call-next-method cand prefix suffix index start))
    (if (bound-and-true-p vertico-grid-mode)
        (if (= vertico--index index)
            (concat (nerd-icons-faicon "nf-fa-hand_o_right") " " cand)
          (concat #("_" 0 1 (display " ")) cand))
      (if (= vertico--index index)
          (concat " " (nerd-icons-faicon "nf-fa-hand_o_right") " " cand)
        (concat "    " cand)))))
#+end_src

*** vertico-directory
#+begin_src emacs-lisp
(setup-after "vertico"
  (setup-lazy '(vertico-directory-delete-char
                vertico-directory-enter
                vertico-directory-delete-word)
    "vertico-directory"
    :prepare
    (setup-keybinds vertico-map
      "<backspace>" 'vertico-directory-delete-char)))
#+end_src

*** vertico-multiform
#+begin_src emacs-lisp
(setup-after "vertico"
  (setup "vertico-multiform"
    (setopt vertico-multiform-caegories '(embark-keybinding grid))
    (vertico-multiform-mode)))
#+end_src

*** vertico-repeat
#+begin_src emacs-lisp
(setup-lazy '(vertico-repeat-save vertico-repeat) "vertico-repeat"
  :prepare (progn
             (setup-hook 'minibuffer-setup-hook
               (vertico-repeat-save))
             (setup-keybinds nil
               "C-r" 'vertico-repeat)))
#+end_src

** Consult
#+begin_src emacs-lisp
(setup-lazy
  '(consult-recent-file
    consult-outline
    consult-line
    consult-buffer
    consult-imenu
    consult-yank-pop)
  "consult"
  :prepare (setup-keybinds nil
             "C-s" 'consult-line
             "C-y" 'consult-yank-pop
             "C-x C-r" 'consult-recent-file
             "C-x b" 'consult-buffer)
  (setq consult-preview-key 'any))
(setup-lazy
  '(consult-ghq-find
    consult-ghq-grep
    consult-ghq-switch-project)
  "consult-ghq"
  (setopt consult-ghq-find-function #'consult-fd
          consult-ghq-grep-function #'consult-ripgrep))
#+end_src

** embark
#+begin_src emacs-lisp
(setup-lazy
  '(embark-act
    embark-dwim
    embark-bindings)
  "embark"
  :prepare (setup-keybinds nil
             "C-." 'embark-act
             "M-." 'embark-dwim
             "C-h B" 'embark-bindings)
  (setup-after "consult"
    (setup "embark-consult"
      (setup-hook 'embark-collect-mode-hook
        'consult-preview-at-point-mode)))

  ;; karthink "fifteen ways to use embark"
  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (let ((aw-dispatch-always t))
             (aw-switch-to-window (aw-select nil))
             (call-interactively (symbol-function ',fn)))))))

  (define-key embark-file-map     (kbd "o") (my/embark-ace-action find-file))
  (define-key embark-buffer-map   (kbd "o") (my/embark-ace-action switch-to-buffer))
  (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))

  (setopt embark-indicators
          '(embark-minimal-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator))
  (setopt embark-help-key "?"))
#+end_src

** Orderless
#+begin_src emacs-lisp
(setup-after "orderless"
  (defun orderless-migemo (component)
    (setup "migemo")
    (let ((pattern (migemo-get-pattern component)))
      (condition-case nil
          (progn (string-match-p pattern "") pattern)
        (invalid-regexp nil))))

  (orderless-define-completion-style orderless-migemo-style
    (orderless-matching-styles '(orderless-literal
                                 orderless-regexp
                                 orderless-migemo)))

  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles orderless-migemo-style))
                                        (eglot (styles orderless))
                                        (eglot-capf (styles orderless))
                                        (org-roam-node (styles orderless-migemo-style)))))
#+end_src

** Prescient
#+begin_src emacs-lisp
(setup-after "precient"
  (prescient-persist-mode t))
#+end_src

** キーバインド
*** which-key
#+begin_src emacs-lisp
(!-
 (setup "which-key"
   (setopt which-key-idle-delay 10000.0
           which-key-idle-secondary-delay 0.05
           which-key-show-early-on-C-h t)
   (which-key-mode)))
#+end_src

*** transient
Hydraからtransient.elにひっこす
どうやらprefixが呼ばれた時点で全てのsuffixをloadするという挙動をする?ので、
雑に呼ぶととんでもない時間がかかる

#+begin_src emacs-lisp
(setup-lazy
  '(avy-menu
    eglot-menu
    main-menu
    major-mode-menu)
  "transient"
  :prepare (setup-keybinds nil
             "M-SPC" 'major-mode-menu)
  (setopt transient-align-variable-pitch t)
  (transient-define-prefix avy-menu ()
    "Avy menu"
    [["Line"
      ("y" "yank" avy-copy-line)
      ("m" "move" avy-move-line)
      ("k" "kill" avy-kill-whole-line)]
     ["Region"
      ("Y" "yank" avy-copy-region)
      ("M" "move" avy-move-region)
      ("K" "kill" avy-kill-region)]
     ["Char"
      ("c" "Char" avy-goto-char)
      ("C" "Char 2" avy-goto-char-2)
      ("t" "Timer" avy-goto-char-timer)]
     ["Word"
      ("w" "Word" avy-goto-word-0)
      ("W" "Word 1" avy-goto-word-1)]
     ["Line"
      ("l" "Line" avy-goto-line)]])
  (transient-define-prefix eglot-menu ()
    "LSP Menu"
    [["Buffer"
      ("f" "Format" eglot-format-buffer)
      ("a" "Action" eglot-code-actions)]
     ["Server"
      ("S" "Shutdown" eglot-shutdown)
      ("M-r" "Reconnect" eglot-reconnect)]
     ["Symbol"
      ("d" "Declaration" eglot-find-declaration)
      ("R" "Reference" eglot-x-find-refs)
      ("i" "Implementation" eglot-find-implementation)
      ("t" "Type" eglot-find-typeDefinition)
      ("r" "Rename" eglot-rename)]])
  (transient-define-prefix main-menu ()
    "Main Menu"
    [["File"
      ("f" "Find" find-file)
      ("r" "Recent" recentf)
      ("o" "Outline" consult-outline)]
     ["Window"
      ("b" "Buffer" consult-buffer)
      ("w" "Ace" ace-window)]
     ["Org"
      ("a" "Agenda" org-agenda)
      ("n" "Find Note" org-roam-node-find)
      ("c" "Capture" my/org-capture-fleeting)
      ("C" "View Fleeting" my/org-capture-fleeting)]
     ["Tool"
      ("z" "Undo Tree" vundo)
      ("g" "Magit" magit-status)
      ("t" "Terminal" vterm)
      ("SPC" "Major Mode Menu" major-mode-menu)]])
  (transient-define-prefix major-mode-menu ()
    ["Org"
     :if-mode (org-mode)
     ["Outline"
      ("n" "Next Head" outline-next-visible-heading :transient t)
      ("p" "Prev Head" outline-previous-visible-heading :transient t)
      ("o" "Outlines" consult-outline)]
     ["TODOs"
      ("t" "DONE" org-todo)
      ("s" "Schedule" org-schedule)
      ("d" "Deadline" org-deadline)
      ("a" "Agenda" org-agenda)]
     ["Babel"
      ("e" "Eval" org-babel-confirm-evaluate)
      ("x" "Tangle" org-babel-tangle)]
     ["Roam"
      ("i" "Insert Link" org-roam-node-insert)
      ("j" "Daily Note" org-roam-dailies-goto-today)]
     ])
  )
#+end_src

** Popper
#+begin_src emacs-lisp
(!-
 (setup "popper"
   (setup-keybinds nil
     "C-`" 'popper-toggle
     "M-`" 'popper-cycle
     "C-M-`" 'popper-toggle-type)
   (setopt popper-reference-buffers
           '("\\*Messages\\*"
             "Output\\*$"
             "\\*Async Shell Command\\*"
             help-mode
             compilation-mode
             vterm-mode))
   (popper-mode +1)))
#+end_src

** Avy/Ace
*** Avy
#+begin_src emacs-lisp
(setup-lazy '(avy-goto-char
              avy-goto-char-2
              avy-goto-char-timer
              avy-goto-word-1
              avy-goto-word-0
              avy-goto-line
              avy-resume
              avy-goto-migemo-char-timer)
  "avy"
  :prepare (setup-keybinds nil
             "C-:" 'avy-goto-migemo-char-timer)
  (defun avy-goto-migemo-char-timer (&optional arg)
    (interactive "P")
    (setup "migemo")
    (let ((avy-all-windows (if arg
                               (not avy-all-windows)
                             avy-all-windows)))
      (avy-with avy-goto-migemo-char-timer
        (setq avy--old-cands (avy--read-candidates #'migemo-get-pattern))
        (avy-process avy--old-cands))))
  (add-to-list 'avy-styles-alist '(avy-goto-migemo-char-timer . pre))
  (defun avy-action-embark (pt)
    (setup "embark")
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)
  (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)
  )
#+end_src

*** Ace-window
https://karthinks.com/software/emacs-window-management-almanac
これ見て良い感じにしたい
#+begin_src emacs-lisp
(setup-lazy '(ace-window
              ace-window-one-command
              ace-window-prefix)
  "ace-window"
  :prepare (setup-keybinds nil
             "C-x o" 'ace-window)
  (setopt aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)
          aw-dispatch-always t)
  (defun ace-window-one-command ()
    (interactive)
    (let ((win (aw-select " ACE")))
      (when (windowp win)
        (with-selected-window win
          (let* ((command (key-binding
                           (read-key-sequence
                            (format "Run in %s..." (buffer-name)))))
                 (this-command command))
            (call-interactively command))))))
  (defun ace-window-prefix ()
    (interactive)
    (display-buffer-override-next-command
     (lambda (buffer _)
       (let (window type)
         (setq
          window (aw-select (propertize " ACE" 'face 'mode-line-highlight))
          type 'reuse)
         (cons window type)))
     nil "[ace-window]")
    (message "Use `ace-window' to display next command buffer...")))
#+end_src

** migemo
"@cmigemo"なる部分はnixでインストールされたパスを置換するためのplace holder
#+begin_src emacs-lisp
(setup-after "migemo"
  (setq migemo-command "cmigemo"
        migemo-options '("-q" "--emacs")
        migemo-dictionary "@cmigemo@/share/migemo/utf-8/migemo-dict"
        migemo-user-dictionary nil
        migemo-regex-dictionary nil
        migemo-coding-system 'utf-8-unix)
  (migemo-init))
#+end_src

** fcitx
#+begin_src emacs-lisp
(!when (equal system-type 'gnu/linux)
  (when (display-graphic-p)
    (!-
     (setup "fcitx"
       (setq fcitx-use-dbus 'fcitx5
             fcitx-remote-command "fcitx5-remote")
       (fcitx-default-setup)))))
#+end_src

** SKK
#+begin_src emacs-lisp :tangle no
(unless (display-graphic-p)
  (!-
   (setup "ddskk-autoloads"
          (setup-keybinds nil "C-x C-j" 'skk-mode)
          (setq default-input-method "japanese-skk"))))

(setup-after "skk"
  (setq skk-preload t)
  (setup "ddskk-posframe"
    (setup-hook 'skk-mode-hook 'ddskk-posframe-mode))
  (when (equal window-system 'mac)
    (add-hook 'focus-in-hook
              #'(lambda ()
                  (when (fboundp 'mac-auto-ascii-setup-input-source)
                    (mac-auto-ascii-setup-input-source))))))

(setup-after "skk-vars"
  (setq skk-user-directory "~/SKK")
  (setq skk-large-jisyo "~/SKK/SKK-JISYO.L")
  (setq skk-jisyo (cons "~/SKK/skk-jisyo" 'utf-8))
  (setq skk-delete-implies-kakutei nil)
  (setq skk-henkan-strict-okuri-precedence t)
  ;; (setq skk-egg-like-newline t)
  (setq skk-kutouten-type 'jp)
  (setq skk-use-auto-kutouten t)
  (setq skk-check-okurigana-on-touroku 'ask)
  (setq skk-status-indicator 'minor-mode)
  (setq skk-show-icon nil)
  (setq skk-show-annotation t)
  (setq skk-show-mode-show t)
  (setq skk-dcomp-activate t)
  (setq skk-dcomp-multiple-activate t)
  (setq skk-azik-keyboard-type 'us101)
  (setq skk-use-azik t)
  (setq skk-azik-keyboard-type (!cond
                                ((equal window-system 'pgtk) 'us101)
                                (t 'jp106)))
  (setq skk-rom-kana-rule-list
        '(("q" nil skk-toggle-characters)
          ("!" nil skk-purge-from-jisyo)
          ("[" nil ("「" . "「"))))

  (defun my/skk-azik-ext-okuri (input output)
    (let* ((fun (lambda (arg)
                  (cond
                   (skk-katakana (insert (car output)))
                   ((and (not skk-katakana) skk-j-mode) (insert (cdr output))))
                  (skk-set-char-before-as-okurigana)))
           (fname (concat "my/skk-azik-ext-okuri-" input))
           (fsymbol (intern fname)))
      (fset fsymbol fun)
      (list input nil fsymbol)))
  (setq skk-azik-extension-okuri-list
        '(;; Q=aI
          ("kQ" ("カイ" . "かい"))
          ("sQ" ("サイ" . "さい"))
          ("tQ" ("タイ" . "たい"))
          ("nQ" ("ナイ" . "ない"))
          ("hQ" ("ハイ" . "はい"))
          ("mQ" ("マイ" . "まい"))
          ("yQ" ("ヤイ" . "やい"))
          ("rQ" ("ライ" . "らい"))
          ("wQ" ("ワイ" . "わい"))
          ;; H=uU
          ("kH" ("クウ" . "くう"))
          ("sH" ("スウ" . "すう"))
          ("tH" ("ツウ" . "つう"))
          ("nH" ("ヌウ" . "ぬう"))
          ("hH" ("フウ" . "ふう"))
          ("mH" ("ムウ" . "むう"))
          ("yH" ("ユウ" . "ゆう"))
          ("rH" ("ルウ" . "るう"))
          ;; W=eI
          ("kW" ("ケイ" . "けい"))
          ("sW" ("セイ" . "せい"))
          ("tW" ("テイ" . "てい"))
          ("nW" ("ネイ" . "ねい"))
          ("hW" ("ヘイ" . "へい"))
          ("mW" ("メイ" . "めい"))
          ("rW" ("レイ" . "れい"))
          ;; P=oU
          ("kP" ("コウ" . "こう"))
          ("sP" ("ソウ" . "そう"))
          ("tP" ("トウ" . "とう"))
          ("nP" ("ノウ" . "のう"))
          ("hP" ("ホウ" . "ほう"))
          ("mP" ("モウ" . "もう"))
          ("yP" ("ヨウ" . "よう"))
          ("rP" ("ロウ" . "ろう"))
          ;; Z=aN
          ("kZ" ("カン" . "かん"))
          ("sZ" ("サン" . "さん"))
          ("tZ" ("タン" . "たん"))
          ("nZ" ("ナン" . "なん"))
          ("hZ" ("ハン" . "はん"))
          ("mZ" ("マン" . "まん"))
          ("yZ" ("ヤン" . "やん"))
          ("rZ" ("ラン" . "らん"))
          ("wZ" ("ワン" . "わん"))
          ;; K=iN
          ("kK" ("キン" . "きん"))
          ("sK" ("シン" . "しん"))
          ("tK" ("チン" . "ちん"))
          ("nK" ("ニン" . "にん"))
          ("hK" ("ヒン" . "ひん"))
          ("mK" ("ミン" . "みん"))
          ("rK" ("リン" . "りん"))
          ;; J=uN
          ("kJ" ("クン" . "くん"))
          ("sJ" ("スン" . "すん"))
          ("tJ" ("ツン" . "つん"))
          ("nJ" ("ヌン" . "ぬん"))
          ("hJ" ("フン" . "ふん"))
          ("mJ" ("ムン" . "むん"))
          ("yJ" ("ユン" . "ゆん"))
          ("rJ" ("ルン" . "るん"))
          ;; D=eN
          ("kD" ("ケン" . "けん"))
          ("sD" ("セン" . "せん"))
          ("tD" ("テン" . "てん"))
          ("nD" ("ネン" . "ねん"))
          ("hD" ("ヘン" . "へん"))
          ("mD" ("メン" . "めん"))
          ("rD" ("レン" . "れん"))
          ;; L=oN
          ("kL" ("コン" . "こん"))
          ("sL" ("ソン" . "そん"))
          ("tL" ("トン" . "とん"))
          ("nL" ("ノン" . "のん"))
          ("hL" ("ホン" . "ほん"))
          ("mL" ("モン" . "もん"))
          ("yL" ("ヨン" . "よん"))
          ("rL" ("ロン" . "ろん"))))
  (dolist (elem skk-azik-extension-okuri-list)
    (let ((rule (my/skk-azik-ext-okuri (car elem) (cadr elem))))
      (add-to-list 'skk-rom-kana-rule-list rule)))
  )
#+end_src

** Org
*** 本体
#+begin_src emacs-lisp
(setup-after "org"
  (setq org-return-follows-link t
        org-mouse-1-follows-link t
        org-directory "~/Org"
        org-startup-indented t
        org-pretty-entities t
        org-use-sub-superscripts "{}"
        org-hide-emphasis-markers t
        org-startup-with-inline-images t
        org-image-actual-width '(300)
        org-preview-latex-default-process 'dvisvgm
        org-preview-latex-image-directory
        (file-name-concat org-directory "resources/ltximg/")
        org-format-latex-header
        "
<<latex-header>>"
        org-id-method 'ts
        org-todo-keywords
        '((sequence "TODO(t)" "INPROGRESS(p!)" "WAIT(w)" "SOMEDAY(s)"
                    "|" "DONE(d!)" "CANCELED(c)"))
        org-use-fast-todo-selection 'expert
        org-log-into-drawer t
        org-log-done nil))
(setup-hook 'org-mode-hook 'org-cdlatex-mode)
(setup-hook 'org-mode-hook 'my/proportional-font)
(setup-hook 'org-mode-hook 'visual-line-mode)
(setup-hook 'org-mode-hook (setq-local line-spacing 0.2))

#+end_src

LaTeX数式のプレビューのときのヘッダー
#+name: latex-header
#+begin_src latex :tangle no
\\documentclass{article}
\\usepackage[usenames]{color}
[DEFAULT-PACKAGES]
[PACKAGES]
% --- edit ---
\\usepackage{physics2}
\\usepackage{diffcoeff}
\\usephysicsmodule{ab, ab.braket}
% vector analysis
\\DeclareMathOperator{\\grad}{\\nabla}
\\DeclareMathOperator{\\divergence}{\\nabla\\cdot}
\\let\\divisionsymbol\\div
\\renewcommand{\\div}{\\divergence}
\\DeclareMathOperator{\\rot}{\\nabla\\times}
%
\\renewcommand{\\Re}{\\operatorname{Re}}
\\renewcommand{\\Im}{\\operatorname{Im}}
\\newcommand{\\Tr}{\\operatorname{Tr}}
\\newcommand{\\rank}{\\operatorname{rank}}
% --- end ---
\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
#+end_src

*** org-tempo
#+begin_src emacs-lisp
(setup-after "org"
  (setup "org-tempo"))
#+end_src

*** org-src
#+begin_src emacs-lisp
(setup-after "org-src"
  (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-src-preserve-indentation t
        org-edit-src-content-indentation 0)
  (add-to-list 'org-src-lang-modes '("typst" . typst-ts)))
#+end_src
**** org-src-context
org-srcでLSPを使えるようにする
ちょっとbuggyな挙動をするので（そもそもそういうHackなので）やめる
#+begin_src emacs-lisp :tangle no
(setup-after "org-src"
  (setup "org-src-context"
    (org-src-context-mode t)))
#+end_src

*** ob
:fileで出力する先のデフォルトを設定
をしていたんだけど、org-attachにしてしまうことにした!<2024-08-04 Sun>
:dir attachだとattachのディレクトリで実行しようとするのでorg-srcでひっかかる
:output-dirで(org-attach-dir)を実行する
#+begin_src emacs-lisp
(setup-after "ob"
  (add-to-list 'org-babel-default-header-args
               '(:output-dir . (lambda () (org-attach-dir nil t))))
  <<babel-lazy-loading-2>>
  <<babel-tangle>>
  <<babel-fix-hash>>
  )
(setup-after "ob-C"
  (setopt org-babel-C-compiler "clang"))
#+end_src

**** Org-babelの言語は起動時に全部読もうとして大変なので遅延する
https://misohena.jp/blog/2022-08-16-reduce-org-mode-startup-time-org-babel.html
なんか動かなくなったのでやめた<2024-07-27 Sat>
これはorg-babel-execute-blockの引数が変わった影響でadviceがおかしくなってる
#+name: babel-lazy-loading
#+begin_src emacs-lisp :tangle no
(defvar my-org-babel-languages
  ;;(<langname> . ob-<filename>.el)
  '((elisp . emacs-lisp)
    (emacs-lisp . emacs-lisp)
    (makefile . makefile)
    (ditaa . ditaa)
    (dot . dot)
    (plantuml . plantuml)
    (perl . perl)
    (cpp . C)
    (C++ . C)
    (D . C)
    (C . C)
    (js . js)
    (java . java)
    (org . org)
    (R . R)
    (gnuplot . gnuplot)
    (julia . julia-vterm)
    (julia-vterm . julia-vterm)
    (ocaml . ocaml)
    (python . python)
    (shell . shell)
    (sh . shell)
    (bash . shell)
    (zsh . shell)
    (fish . shell)
    (csh . shell)
    (ash . shell)
    (dash . shell)
      (ksh . shell)
      (mksh . shell)
      (posh . shell)))

(defun my-org-babel-language-files ()
  "重複しない全ての言語バックエンドファイル名を返す。"
  (seq-uniq (mapcar #'cdr my-org-babel-languages)))

;; my-org-babel-languagesからorg-babel-load-languagesを設定する。
;; org-lintやorg-pcompleteにorg-babel-load-languagesを使った処理がある
;; ようなので。
;; このときcustom-set-variablesを使わないようにすること。
;; org-babel-do-load-languagesが呼ばれて全部読み込まれてしまうので。
(setq org-babel-load-languages
      (mapcar (lambda (lang) (cons lang t)) ;;(emacs-lisp . t)のような形式
              (my-org-babel-language-files)))

(defun my-org-require-lang-file (lang-file-name)
  "ob-LANG-FILE-NAME.elを読み込む。"
  (when lang-file-name
    (require (intern (format "ob-%s" lang-file-name)) nil t)))

(defun my-org-require-lang (lang)
  "LANGを読み込む。"
  (my-org-require-lang-file
   (alist-get
    (if (stringp lang) (intern lang) lang)
    my-org-babel-languages)))

(defun my-org-require-lang-all ()
  "全ての言語を読み込む。"
  (mapc #'my-org-require-lang-file
        (my-org-babel-language-files)))

;; org-elementで言語名を返す時、その言語をロードする。
(advice-add #'org-element-property :around #'my-org-element-property)
(defun my-org-element-property (original-fun property element)
  (let ((value (funcall original-fun property element)))
    (when (eq property :language)
      (my-org-require-lang value))
    value))

;; ob-table.elに(org-babel-execute-src-block nil (list "emacs-lisp" "results" params))
;; のような呼び出し方をする所があるので。
(advice-add #'org-babel-execute-src-block :around
            #'my-org-babel-execute-src-block)
(defun my-org-babel-execute-src-block (original-fun
                                       &optional arg info params executor-type)
  (my-org-require-lang (nth 0 info))
  (funcall original-fun arg info params executor-type))

;; (match-string)の値を直接langとして渡しているので。
(advice-add #'org-babel-enter-header-arg-w-completion :around
            #'my-org-babel-enter-header-arg-w-completion)
(defun my-org-babel-enter-header-arg-w-completion (original-fun
                                                   lang)
  (my-org-require-lang lang)
  (funcall original-fun lang))

;; org-lint(org-lint-wrong-header-argument, org-lint-wrong-header-value)内で参照しているので。
;; 面倒なので全部読み込んでしまう。
(advice-add #'org-lint :around #'my-org-lint)
(defun my-org-lint (original-fun &rest args)
  (my-org-require-lang-all)
  (apply original-fun args))
#+end_src

**** Org-babelの遅延ロードその2
doom-emacsからパクってくる
#+name: babel-lazy-loading-2
#+begin_src emacs-lisp :tangle no
(defvar my/org-babel-languages-alist
  '((c . C)
    (cpp . C)
    (C++ . C)
    (elisp . emacs-lisp)
    (sh . shell)
    (bash . shell)))

(defun my/org-babel-lazy-load (lang &optional async)
  (cl-check-type lang (or symbol null))
  (unless (cdr (assq lang org-babel-load-languages))
    (when async
      ;; ob-async has its own agenda for lazy loading packages (in the child
      ;; process), so we only need to make sure it's loaded.
      (require 'ob-async nil t))
    (prog1 (or (run-hook-with-args-until-success '+org-babel-load-functions lang)
               (require (intern (format "ob-%s" lang)) nil t)
               (require lang nil t))
      (add-to-list 'org-babel-load-languages (cons lang t)))))

(defun my/org-export-lazy-load-library-h (&optional element)
  "Lazy load a babel package when a block is executed during exporting."
  (my/org-babel-lazy-load-library-a (org-babel-get-src-block-info nil element)))

(advice-add #'org-babel-exp-src-block :before #'my/org-export-lazy-load-library-h)

(defun my/org-src-lazy-load-library-a (lang)
  "Lazy load a babel package to ensure syntax highlighting."
  (or (cdr (assoc lang org-src-lang-modes))
      (my/org-babel-lazy-load lang)))

(advice-add #'org-src--get-lang-mode :before #'my/org-src-lazy-load-library-a)

;; This also works for tangling
(defun my/org--babel-lazy-load-library-a (info)
  "Load babel libraries lazily when babel blocks are executed."
  (let* ((lang (nth 0 info))
         (lang (cond ((symbolp lang) lang)
                     ((stringp lang) (intern lang))))
         (lang (or (cdr (assq lang +org-babel-mode-alist))
                   lang)))
    (my/org-babel-lazy-load
     lang (and (not (assq :sync (nth 2 info)))
               (assq :async (nth 2 info))))
    t))

(advice-add #'org-babel-confirm-evaluate :after-while #'my/org-babel-lazy-load-library-a)

(advice-add #'org-babel-do-load-languages :override #'ignore)
#+end_src

**** Tangle/Detangleで対応する箇所を行き来できるように
https://github.com/gmoutso/dotemacs/blob/master/lisp/tanglerc.el

#+name: babel-tangle
#+begin_src emacs-lisp :tangle no
;; to be used with header arguments :tangle yes :comments yes :noweb yes

(setq org-babel-tangle-comment-format-beg
      "%% [[%link][%source-name]]")

(defun gm/org-babel-get-block-header (&optional property)
  "Returns alist of header properties of this block or specific PROPERTY.
   Eg., use with PROPERTY :results or :session."
  (let* ((info (org-babel-get-src-block-info 'light))
         (properties (nth 2 info)))
    (if property (cdr (assq property properties))
      properties)))

;; To be able to go to jump to the link in tangled file from a given block in org
;; we need the comment link using 'gm/org-babel-tangle-get-this-comment-link
;; most functions here try to get this (viz. getting the counter used in the link)

(defun gm/org-babel-tangle-count-this ()
  "Count source block number in section.

Note, does not give correct file search field in orglink as in the tangled file if before all headings!"
  (let ((here (point))
        (beg (org-with-wide-buffer
              (org-with-limited-levels (or (outline-previous-heading) (point-min))))))
    (let ((case-fold-search nil))
      (count-matches "^ *#\\+begin_src" beg here))))

(defun gm/org-babel-tangle-get-this-comment-link ()
  "Extracts the org link that comments the source block in the tangled file."
  (pcase-let*
      ((counter (gm/org-babel-tangle-count-this))
       (tangled-block (org-babel-tangle-single-block counter))
       (`(,start ,file ,link ,source ,info ,body ,comment) tangled-block)
       (link-data `(("start-line" . ,(number-to-string start))
                    ("file" . ,file)
                    ("link" . ,link)
                    ("source-name" . ,source))))
    (org-fill-template
     org-babel-tangle-comment-format-beg link-data)))

(defun gm/goto-tangled-block ()
  "The opposite of `org-babel-tangle-jump-to-org'. Jumps at tangled code from org src block.

https://emacs.stackexchange.com/a/69591"
  (interactive)
  (if (org-in-src-block-p)
      (let* ((header (car (org-babel-tangle-single-block 1 'only-this-block)))
             ;; ("test.py" ("python" 9 "test.org" "file:test.org::*a" "a:1" properties code nil))
             ;; if tangle is no then car will be nil!
             (tangle (car header))
             (rest (cadr header))
             (lang (car rest))
             (org-buffer (nth 2 rest))
             (org-id (nth 3 rest))
             (source-name (nth 4 rest))
             (search-comment (gm/org-babel-tangle-get-this-comment-link))
             (file (expand-file-name
                    (org-babel-effective-tangled-filename org-buffer lang tangle))))
        (if (not (file-exists-p file))
            (message "File does not exist. 'org-babel-tangle' first to create file.")
          (find-file file)
          (beginning-of-buffer)
          (search-forward search-comment)))
    (message "Cannot jump to tangled file because point is not at org src block.")))

(defun gm/tangle-and-goto-block ()
  "Goes to the tangled file at the source block."
  (interactive)
  (let ((current-prefix-arg 8))
    (call-interactively 'org-babel-tangle))
  (gm/goto-tangled-block))

(defun gm/detangle-and-goto-block ()
  "Detangle and go to block at point.

Note sure why this was written: all languages must be the same in org file."
  (interactive)
  (let ((org-src-preserve-indentation t))
    (org-babel-detangle))
  (org-babel-tangle-jump-to-org))
#+end_src

**** ファイル名を決めるときのハッシュが弱すぎて衝突するので修正
#+name: babel-fix-hash
#+begin_src emacs-lisp :tangle no
(defun my/org-babel-temp-stable-file-fixed (data prefix &optional suffix)
  "Fixed version of org-babel-temp-stable-file.
   Original function uses sxhash, but
   sxhash see only head 7 elements of list.
   This behavior is not appropriate for file name."
  (let ((path (format "%s%s%s%s"
                      (file-name-as-directory (org-babel-temp-stable-directory))
                      prefix
                      (secure-hash 'md5 (format "%s" data))
                      ;; use md5 instead of sxhash
                      ;; this function will not be called frequently,
                      ;; so hash performance doesn't matter.
                      (or suffix ""))))
    (with-temp-file path)
    path))
(advice-add 'org-babel-temp-stable-file :override #'my/org-babel-temp-stable-file-fixed)
#+end_src

**** org-nix-shell
nix-shellの環境下でbabel-executeできるようにするやつ
#+begin_src emacs-lisp
(setup-lazy '(org-nix-shell-mode) "org-nix-shell"
  :prepare (setup-hook 'org-mode-hook 'org-nix-shell-mode))
#+end_src

*** ox
Export先のデフォルトのディレクトリを指定

#+begin_src emacs-lisp
(setup-after "ox"
  (defvar org-export-directory "~/Org/export")
  (defun org-export-output-file-name--set-directory
      (orig-fn extension &optional subtreep pub-dir)
    (setq pub-dir (or pub-dir org-export-directory))
    (funcall orig-fn extension subtreep pub-dir))
  (advice-add 'org-export-output-file-name
              :around 'org-export-output-file-name--set-directory))
#+end_src

*** ox-latex
#+begin_src emacs-lisp
(setup-after "ox-latex"
  (setq org-latex-pdf-process '("latexmk -f -pdfdvi -gg -output-directory=%o %f"))
  (setq org-export-in-background t)
  (setq org-file-apps '(("pdf" . emacs)))
  (setq org-latex-default-class "jlreq")
  (add-to-list 'org-latex-classes
               '("jlreq"
                 "
<<ox-latex-header>>"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

#+name: ox-latex-header
#+begin_src latex :tangle no
\\documentclass[11pt,paper=a4]{jlreq}
[NO-DEFAULT-PACKAGES]
\\usepackage{amsmath}
\\ifdefined\\kanjiskip
  \\usepackage[dvipdfmx]{graphicx}
  \\usepackage[dvipdfmx]{hyperref}
  \\usepackage{pxjahyper}
  \\hypersetup{colorlinks=true}
\\else
  \\usepackage{graphicx}
  \\usepackage{hyperref}
  \\hypersetup{pdfencoding=auto,colorlinks=true}
\\fi
[PACKAGES]
#+end_src

*** ox-gfm
#+begin_src emacs-lisp
(setup-after "org"
  (setup "ox-gfm-autoloads"))
#+end_src

*** org-crypt
#+begin_src emacs-lisp
(setup-after "org"
  (setup "org-crypt"
    (org-crypt-use-before-save-magic)
    (add-to-list 'org-tags-exclude-from-inheritance "crypt")
    (setq org-crypt-key nil)
    (setq-local auto-save-default nil)))
#+end_src

*** org-capture
#+begin_src emacs-lisp
(setup-lazy '(org-capture
              my/org-capture-fleeting)
  "org-capture"
  :prepare (setup-keybinds nil
             "C-c c" 'my/org-capture-fleeting)
  (setq fleeting-file (file-name-concat org-directory "inbox.org"))
  (setq org-capture-templates
        '(
          ("f" "Fleeting" entry (file fleeting-file) "* %?\n")
          ))
  (defun my/org-capture-fleeting ()
    (interactive)
    (org-capture nil "f")))
#+end_src

*** org-roam
https://jethrokuan.github.io/org-roam-guide/
https://magnus.therning.org/2021-07-23-keeping-todo-items-in-org-roam-v2.html
ディレクトリをflatにした
とりあえずは何でも放り込むところとしてorg-roam-dailiesを使っているけど、後でRoamに整理するときに日付まで追う必要があって大変なので
普通にorg-capture使ったほうが良いかも

#+begin_src emacs-lisp
(setup-lazy '(org-roam-node-find
              org-roam-node-insert
              org-roam-tag-add)
  "org-roam"
  :prepare (setup-keybinds nil
             "C-c n" 'org-roam-node-find)
  (setq org-roam-db-location "~/.emacs.d/org-roam.db"
        org-roam-directory "~/Org/roam"
        org-roam-completion-functions '()
        org-roam-verbose nil
        org-roam-node-display-template (concat "${title:*} " (propertize "${tags:15}" 'face 'org-tag))
        org-roam-capture-templates
        '(("m" "main" plain
           "%?"
           :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n")
           :immediate-finish t
           :unnarrowed t)
          ("r" "reference" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${title}.org"
                      "#+title: ${title}\n#+filetags: :reference:\n")
           :immediate-finish t
           :unnarrowed t)
          ("a" "article" plain "%?"
           :if-new
           (file+head "%<%Y%m%d%H%M%S>-${title}.org"
                      "#+title: ${title}\n#+filetags: :article:\n")
           :immediate-finish t
           :unnarrowed t)))
  ;; Update tags for TODO
  (defun my/roam-get-filetags ()
    (split-string (or (org-roam-get-keyword "filetags") "")))

  (defun my/roam-add-filetag (tag)
    (let* ((new-tags (cons tag (my/roam-get-filetags)))
           (new-tags-str (combine-and-quote-strings new-tags)))
      (org-roam-set-keyword "filetags" new-tags-str)))

  (defun my/roam-del-filetag (tag)
    (let* ((new-tags (seq-difference (my/roam-get-filetags) `(,tag)))
           (new-tags-str (combine-and-quote-strings new-tags)))
      (org-roam-set-keyword "filetags" new-tags-str)))

  (defun my/roam-todo-p ()
    "Return non-nil if current buffer has any TODO entry.
     TODO entries marked as done are ignored, meaning the this
     function returns nil if current buffer contains only completed
     tasks."
    (org-element-map
        (org-element-parse-buffer 'headline)
        'headline
      (lambda (h)
        (eq (org-element-property :todo-type h)
            'todo))
      nil 'first-match))

  (defun my/roam-update-todo-tag ()
    "Update TODO tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (org-roam-file-p))
      (org-with-point-at 1
        (let* ((tags (my/roam-get-filetags))
               (is-todo (my/roam-todo-p)))
          (cond ((and is-todo (not (seq-contains-p tags "TODO")))
                 (my/roam-add-filetag "TODO"))
                ((and (not is-todo) (seq-contains-p tags "TODO"))
                 (my/roam-del-filetag "TODO")))))))
  (add-hook 'find-file-hook #'my/roam-update-todo-tag)
  (add-hook 'before-save-hook #'my/roam-update-todo-tag)
  (org-roam-db-autosync-mode t))

(setup-lazy '(org-roam-dailies-goto-date
              org-roam-dailies-capture-date
              org-roam-dailies-goto-today
              org-roam-dailies-capture-today
              org-roam-dailies-find-directory)
  "org-roam-dailies"
  (setopt org-roam-dailies-directory "daily/"
          org-roam-dailies-capture-templates
          '(("d" "default" entry
             "* %<%I:%M %p>: %?"
             :if-new (file+head "%<%Y-%m-%d>.org"
                                "#+title: %<%Y-%m-%d>\n#+filetags: :daily:\n")))))
#+end_src

**** vulpea
どうやらvulpeaがらみでdbの同期が死んだ
使うのをやめる
#+begin_src emacs-lisp :tangle no
(ensure 'vulpea)
(setup-lazy '(vulpea-db-autosync-mode) "vulpea"
  :prepare (setup-hook 'org-roam-db-autosync-mode-hook 'vulpea-db-autosync-mode))
#+end_src

org-roamのファイルからTODOがあるやつだけ抜き出してagenda-filesにする
https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html
別にvulpea依存無くせそう
#+begin_src emacs-lisp :tangle no
(setup-lazy '(vulpea-agenda-files-update) "vulpea"
  (setup "vulpea-buffer")
  (defun vulpea-project-p ()
    "Return non-nil if current buffer has any todo entry.
    TODO entries marked as done are ignored, meaning the this
    function returns nil if current buffer contains only completed
    tasks."
    (org-element-map
        (org-element-parse-buffer 'headline)
        'headline
      (lambda (h)
        (eq (org-element-property :todo-type h)
            'todo))
      nil 'first-match))

  (defun vulpea-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "task" tags))
            (setq tags (remove "task" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

  (defun vulpea-buffer-p ()
    "Return non-nil if the currently visited buffer is a note."
    (and buffer-file-name
         (string-prefix-p
          (expand-file-name (file-name-as-directory org-roam-directory))
          (file-name-directory buffer-file-name))))

  (defun vulpea-project-files ()
    "Return a list of note files containing 'task' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
                :from tags
                :left-join nodes
                :on (= tags:node-id nodes:id)
                :where (like tag (quote "%\"task\"%"))]))))

  (defun vulpea-agenda-files-update (&rest _)
    "Update the value of `org-agenda-files'."
    (setq org-agenda-files (vulpea-project-files)))

  (add-hook 'find-file-hook #'vulpea-project-update-tag)
  (add-hook 'before-save-hook #'vulpea-project-update-tag)

  (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
  (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
  (add-to-list 'org-tags-exclude-from-inheritance "task")
  (defun org-roam-tag-new-node-as-draft ()
    (org-roam-tag-add '("draft")))
  (add-hook 'org-roam-capture-new-node-hook #'org-roam-tag-new-node-as-draft))

#+end_src

**** org-roam-ql
#+begin_src emacs-lisp
(setup-lazy '(my/roam-update-agenda-files
              org-roam-ql-search
              org-roam-ql-nodes
              org-roam-ql-agenda-block
              org-roam-ql-nodes-files)
  "org-roam-ql"
  :prepare (advice-add 'org-agenda :before #'my/roam-update-agenda-files)
  (defun my/roam-update-agenda-files (&rest r)
    (setq org-agenda-files (org-roam-ql-nodes-files '(tags "TODO")))))
#+end_src

*** org-modern
使ってたけど、あんまり使い勝手がよくないかもなのでやめてorg-bulletだけつかう
やっぱり戻ってきた
#+begin_src emacs-lisp
(setup-lazy '(org-modern-mode
              org-modern-agenda)
  "org-modern"
  :prepare (progn (setup-hook 'org-mode-hook 'org-modern-mode)
                  (setup-hook 'org-agenda-finalize 'org-modern-agenda))
  (setq org-auto-align-tags nil
        org-tags-column 0
        org-catch-invisible-edits 'show-and-error
        org-special-ctrl-a/e t
        org-indent-heading-respect-content t
        org-hide-emphasis-markers t
        org-pretty-entities t
        org-agenda-tags-column 0
        org-agenda-block-separator ?─
        org-agenda-time-grid
        '((daily today require-timed)
          (800 1000 1200 1400 1600 1800 2000)
          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
        org-agenda-current-time-string
        "◀── now ─────────────────────────────────────────────────"
        )
  (setopt org-modern-star 'replace
          org-modern-hide-stars nil
          org-modern-table nil
          org-modern-list '((?* . "•") (?+ . "‣"))))
(setup-lazy '(org-modern-indent-mode)
  "org-modern-indent"
  :prepare (add-hook 'org-mode-hook #'org-modern-indent-mode 90))

#+end_src

*** org-superstar
org-bulletはもう古くて、superstarをつかうらしい
#+begin_src emacs-lisp :tangle no
(ensure 'org-superstar)
(setup-lazy '(org-superstar-mode)
  "org-superstar"
  :prepare (setup-hook 'org-mode-hook 'org-superstar-mode))
#+end_src

*** org-agenda
#+begin_src emacs-lisp
(setup-after "org-agenda"
  (setq org-agenda-span 'week
        org-log-done 'time))
#+end_src

基本Org-qlを使う はやいので
もうつかってません
#+begin_src emacs-lisp :tangle no
(ensure 'org-ql)
(setup-lazy '(org-ql-view) "org-ql-view")
(setup-lazy '(org-ql-search) "org-ql-search")
(setup-lazy '(my/org-agenda
              my/org-todo-list)
  "org-ql"
  (defun my/org-agenda ()
    (interactive)
    (org-ql-search (org-agenda-files)
      '(or (and (not (done))
                (or (scheduled :to +7)
                    (deadline auto)))
           (todo "INPROGRESS" "SOMEDAY" "WAIT")
           (habit))
      :title "Agenda for this week"
      :sort '(todo date priority)
      :super-groups '((:name "Overdue"
                             :deadline past)
                      (:name "Today's TODO"
                             :scheduled today
                             :time-grid t)
                      (:name "Habit"
                             :habit t)
                      (:name "In progress"
                             :todo "INPROGRESS")
                      (:name "Deadline is coming"
                             :deadline future)
                      (:name "Schedule for this week"
                             :scheduled future)
                      (:todo ("WAIT" "SOMEDAY")))))
  (defun my/org-todo-list ()
    (interactive)
    (org-ql-search (org-agenda-files)
      '(and (not (done))
            (todo))
      :title "Todo List"
      :sort '(todo date)
      :super-groups '((:name "Overdue"
                             :deadline past))))
  (with-eval-after-load 'org-roam
    (advice-add 'my/org-agenda :before #'vulpea-agenda-files-update)
    (advice-add 'my/org-todo-list :before #'vulpea-agenda-files-update)))

#+end_src

*** calfw-org
#+begin_src emacs-lisp
(setup-lazy '(cfw:open-org-calendar) "calfw-org"
  :prepare (progn
             (setup-keybinds nil
               "C-c a" 'cfw:open-org-calendar)
             (advice-add 'cfw:open-org-calendar :before #'my/roam-update-agenda-files))
  (setq cfw:org-agenda-schedule-args nil))

#+end_src

*** org-attach
#+begin_src emacs-lisp
(setup-after "org-attach"
  (setq org-attach-id-dir "~/Org/resources"
        org-attach-store-link-p 'attached
        org-attach-use-inheritance t
        org-attach-id-to-path-function-list
        '(org-attach-id-ts-folder-format
          org-attach-id-uuid-folder-format)))
#+end_src

*** org-noter
#+begin_src emacs-lisp
(setup-lazy '(org-noter) "org-noter"
  (setq org-noter-notes-window-location 'horizontal-split
        org-noter-always-create-frame nil)
  (org-noter-enable-org-roam-integration))
#+end_src

*** oc,citar
Zoteroで管理してるので、zotero-better-bibtexとcitarの組み合わせでいく
org-roam-bibtexとかもセットアップした方がいいかも
#+begin_src emacs-lisp
(setup-after "oc"
  (setq org-cite-global-bibliography '("~/Zotero/reference.bib")
        org-cite-insert-processor 'citar
        org-cite-follow-processor 'citar
        org-cite-activate-processor 'citar)
  (setup "citar"))
(setup-lazy '(citar-capf-setup) "citar-capf"
   :prepare
   (progn
     (setup-hook 'LaTeX-mode-hook 'citar-capf-setup)
     (setup-hook 'org-mode-hook 'citar-capf-setup)))
(setup-after "citar"
  (setup "citar-org")
  (setq citar-bibliography org-cite-global-bibliography
        citar-open-entry-function #'citar-open-entry-in-zotero))
#+end_src

*** org-appear
#+begin_src emacs-lisp
(setup-lazy '(org-appear-mode) "org-appear"
  :prepare (setup-hook 'org-mode-hook 'org-appear-mode)
  (setq org-appear-autoemphasis t
        org-appear-autolinks t
        org-appear-autosubmarkers t
        org-appear-inside-latex t))
#+end_src

*** org-fragtog
#+begin_src emacs-lisp
(setup-lazy '(org-fragtog-mode) "org-fragtog"
  :prepare (setup-hook 'org-mode-hook 'org-fragtog-mode))
#+end_src

*** org-download
#+begin_src emacs-lisp
(setup-lazy '(org-download-enable
              org-download-yank
              org-download-clipboard)
  "org-download"
  :prepare (setup-hook 'dired-mode-hook 'org-download-enable)
  (setq org-download-method 'attach))
#+end_src

** Calendar
calendar.elもcalfwも使っていく
#+name: calendar.el
#+begin_src emacs-lisp
(setup-after "calendar"
  (setup "japanese-holidays"
    (setup-hook 'calendar-today-visible-hook 'japanese-holiday-mark-weekend)
    (setup-hook 'calendar-today-invisible-hook 'japanese-holiday-mark-weekend)))
#+end_src

#+name: calfw
#+begin_src emacs-lisp
(setup-lazy '(cfw:open-calendar-buffer) "calfw"
  (setup "japanese-holidays")
  ;; Unicode characters
  (setq cfw:fchar-junction ?╋
        cfw:fchar-vertical-line ?┃
        cfw:fchar-horizontal-line ?━
        cfw:fchar-left-junction ?┣
        cfw:fchar-right-junction ?┫
        cfw:fchar-top-junction ?┯
        cfw:fchar-top-left-corner ?┏
        cfw:fchar-top-right-corner ?┓)
  )
#+end_src

#+name: japanese-holidays
#+begin_src emacs-lisp
(setup-after "japanese-holidays"
  (setq calendar-holidays
          (append japanese-holidays holiday-local-holidays holiday-other-holidays)
          calendar-mark-holidays-flag t)
  (setq japanese-holiday-weekend '(0 6)
          japanese-holiday-weekend-marker
          '(holiday nil nil nil nil nil japanese-holiday-saturday)))
#+end_src

** PDF-tools
バイナリが要るのでNix側でインストールする
#+begin_src emacs-lisp
(setup-after "pdf-tools"
  (setopt pdf-cache-image-limit 15
          image-cache-eviction-delay 15
          pdf-view-resize-factor 1.1))
(!-
 (setup "pdf-tools-autoloads")
 (setup "pdf-loader"
   (pdf-loader-install)))
#+end_src

** Eldoc
*** eldoc-box
#+begin_src emacs-lisp
(setup-lazy '(eldoc-box-hover-mode
              eldoc-box-hover-at-point-mode
              eldoc-box-help-at-point)
  "eldoc-box"
  :prepare (setup-hook 'eldoc-mode-hook 'eldoc-box-hover-mode))
#+end_src

** Terminal
*** vterm
#+begin_src emacs-lisp
(setup-lazy '(vterm) "vterm"
  :prepare (setup-keybinds nil
             "C-c t" 'vterm)
  (setopt vterm-shell "nu"
          vterm-timer-delay 0.01))
#+end_src

*** eat
macosだとterminfoをコンパイルし直す必要がある
eat.tiをtic -x eat.tiでコンパイルして、~/.terminfo配下に配置
なんか遅い
#+begin_src emacs-lisp
(setup-lazy '(eat) "eat"
  ;; :prepare (setup-keybinds nil "C-c t" (lambda ()(interactive) (eat "nu")))
  (setopt eat-shell "nu") ;; まだnongnuに降ってきてない
  )
#+end_src

** Dired
*** 本体
#+begin_src emacs-lisp
(setup-after "dired"
  (setopt dired-mouse-drag-files t
          mouse-drag-and-drop-region-cross-program t
          dired-listing-switches "-alh"))
#+end_src
*** Make dired colorful
#+begin_src emacs-lisp
(setup-lazy '(diredfl-mode) "diredfl"
  :prepare (setup-hook 'dired-mode-hook 'diredfl-mode))
#+end_src
*** Icon
#+begin_src emacs-lisp
(setup-lazy '(nerd-icons-dired-mode) "nerd-icons-dired"
  :prepare (setup-hook 'dired-mode-hook 'nerd-icons-dired-mode))
#+end_src
*** subtree
#+begin_src emacs-lisp
(setup-after "dired"
  (setup "dired-subtree"
    (setup-keybinds dired-mode-map
      "i" 'dired-subtree-insert
      ";" 'dired-subtree-remove)))
#+end_src
*** collapse
#+begin_src emacs-lisp
(setup-lazy '(dired-collapse-mode)
  "dired-collapse"
  :prepare (setup-hook 'dired-mode-hook 'dired-collapse-mode))
#+end_src
*** preview
#+begin_src emacs-lisp
(setup-lazy '(dired-preview-mode) "dired-preview"
  :prepare (setup-hook 'dired-mode-hook 'dired-preview-mode))
#+end_src

** Footer
*** provide
#+begin_src emacs-lisp
(provide 'init)
#+end_src
